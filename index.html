<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Macro Scan & Log</title>
  <style>
    :root { color-scheme: light; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 0; background: #f6f7fb; }
    header { padding: 14px 16px; background: #111827; color: #fff; }
    header h1 { font-size: 16px; margin: 0; }
    main { padding: 16px; max-width: 900px; margin: 0 auto; }
    .grid { display: grid; gap: 12px; }
    @media (min-width: 860px){ .grid { grid-template-columns: 1.1fr 0.9fr; } }
    .card { background: #fff; border: 1px solid #e5e7eb; border-radius: 14px; padding: 14px; box-shadow: 0 10px 30px rgba(0,0,0,.04); }
    .row { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    .row3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; }
    label { display: block; font-weight: 650; font-size: 12px; color: #374151; margin: 10px 0 6px; }
    input, select, button {
      width: 100%; padding: 10px 11px; border: 1px solid #d1d5db; border-radius: 12px;
      font-size: 14px; background: #fff;
    }
    button { cursor: pointer; border: 0; background: #2563eb; color: #fff; font-weight: 700; }
    button.secondary { background: #111827; }
    button.ghost { background: #f3f4f6; color: #111827; border: 1px solid #e5e7eb; }
    button.danger { background: #dc2626; }
    .muted { color: #6b7280; font-size: 12px; }
    .pill { display: inline-block; padding: 6px 10px; border-radius: 999px; background: #f3f4f6; border: 1px solid #e5e7eb; font-size: 12px; margin-right: 8px; }
    .ok { background: #ecfdf5; border-color: #10b98133; }
    .warn { background: #fff7ed; border-color: #f59e0b33; }
    .bad { background: #fef2f2; border-color: #ef444433; }
    .videoWrap {
      position: relative;
      width: 100%;
      aspect-ratio: 4 / 3;
      border-radius: 14px;
      overflow: hidden;
      background: #111827;
      border: 1px solid #111827;
    }
    video { width: 100%; height: 100%; object-fit: cover; }
    /* Quagga injects elements into this */
    #quaggaTarget { position:absolute; inset:0; z-index:2; }
    #quaggaTarget video, #quaggaTarget canvas { position:absolute; inset:0; width:100%; height:100%; }
    .status { margin-top: 10px; white-space: pre-wrap; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; font-size: 12px; background: #f3f4f6; border: 1px solid #e5e7eb; padding: 10px; border-radius: 12px; }
    table { width: 100%; border-collapse: collapse; }
    th, td { text-align: left; padding: 10px 8px; border-bottom: 1px solid #e5e7eb; font-size: 13px; vertical-align: top; }
    th { font-size: 12px; color: #374151; }
    .right { text-align: right; }
    .small { font-size: 12px; color: #6b7280; }
    .split { display: flex; gap: 10px; flex-wrap: wrap; }
  </style>
</head>

<body>
<header>
  <h1>Macro Scan & Log (Barcode → Online Lookup → Daily Targets)</h1>
</header>

<main class="grid">
  <!-- LEFT: Scan + Lookup + Add -->
  <section class="card">
    <h2 style="margin:0 0 8px 0; font-size:16px;">Scan & add food</h2>
    <div class="muted">
      iPhone note: Camera works best on HTTPS (GitHub Pages). Aim at the striped UPC/EAN barcode (not QR).
      Tap the video area if you need to refocus; flashlight button appears if supported.
    </div>

    <label>Camera</label>
    <div class="videoWrap" id="videoWrap">
      <video id="video" muted playsinline></video>
      <div id="quaggaTarget"></div>
    </div>

    <div class="split" style="margin-top:10px;">
      <button id="startBtn">Start scanner</button>
      <button id="stopBtn" class="ghost">Stop</button>
      <button id="torchBtn" class="ghost" style="max-width:220px; display:none;">Flashlight: Off</button>
      <select id="cameraSelect" aria-label="Camera selection" style="max-width:280px;"></select>
    </div>

    <label>Barcode (UPC/EAN)</label>
    <div class="row">
      <input id="barcode" placeholder="Scan fills this, or type it" inputmode="numeric" />
      <button id="lookupBtn" class="secondary">Lookup</button>
    </div>

    <div id="productCard" style="display:none; margin-top:12px;">
      <div class="pill ok" id="sourcePill">Source: Open Food Facts</div>
      <div style="margin-top:10px;">
        <div style="font-weight:800;" id="prodName"></div>
        <div class="small" id="prodMeta"></div>
      </div>

      <label>Serving input</label>
      <div class="row3">
        <select id="mode">
          <option value="serving">By serving</option>
          <option value="grams">By grams</option>
        </select>
        <input id="qty" type="number" min="0" step="0.25" value="1" />
        <button id="addBtn">Add to today</button>
      </div>
      <div class="muted" id="modeHelp" style="margin-top:6px;">
        Uses nutrition per serving if available; otherwise per 100g.
      </div>

      <div style="margin-top:10px;" class="status" id="nutriPreview">—</div>
    </div>

    <div class="status" id="status">Ready.</div>
  </section>

  <!-- RIGHT: Targets + Today + Log -->
  <section class="card">
    <h2 style="margin:0 0 8px 0; font-size:16px;">Today’s targets</h2>

    <div class="row">
      <div>
        <label>Calories target</label>
        <input id="tCalories" type="number" min="0" step="10" value="2000" />
      </div>
      <div>
        <label>Protein target (g)</label>
        <input id="tProtein" type="number" min="0" step="5" value="170" />
      </div>
    </div>
    <div class="row">
      <div>
        <label>Carbs target (g)</label>
        <input id="tCarbs" type="number" min="0" step="5" value="200" />
      </div>
      <div>
        <label>Fat target (g)</label>
        <input id="tFat" type="number" min="0" step="5" value="60" />
      </div>
    </div>

    <div class="split" style="margin-top:10px;">
      <button id="saveTargets" class="ghost">Save targets</button>
      <button id="exportCsv" class="ghost">Export CSV</button>
      <button id="clearToday" class="danger">Clear today</button>
    </div>

    <h3 style="margin:14px 0 6px 0; font-size:14px;">Today totals</h3>
    <div id="totals" class="status">—</div>

    <h3 style="margin:14px 0 6px 0; font-size:14px;">Today log</h3>
    <div style="max-height:360px; overflow:auto; border:1px solid #e5e7eb; border-radius:12px;">
      <table>
        <thead>
          <tr>
            <th>Item</th>
            <th class="right">kcal</th>
            <th class="right">P</th>
            <th class="right">C</th>
            <th class="right">F</th>
            <th></th>
          </tr>
        </thead>
        <tbody id="logBody"></tbody>
      </table>
    </div>

    <div class="muted" style="margin-top:10px;">
      Goal reminder: fat loss + keep muscle → keep protein high, lift consistently, use a modest calorie deficit.
    </div>
  </section>
</main>

<!-- Quagga2 (global build). Must be BEFORE the module script -->
<script src="https://cdn.jsdelivr.net/npm/@ericblade/quagga2@1.8.4/dist/quagga.min.js"></script>

<script type="module">
  // ---------- Helpers ----------
  const LS = {
    get(key, fallback) { try { return JSON.parse(localStorage.getItem(key)) ?? fallback; } catch { return fallback; } },
    set(key, val) { localStorage.setItem(key, JSON.stringify(val)); }
  };

  const todayKey = () => {
    const d = new Date();
    const yyyy = d.getFullYear();
    const mm = String(d.getMonth()+1).padStart(2,"0");
    const dd = String(d.getDate()).padStart(2,"0");
    return `log_${yyyy}-${mm}-${dd}`;
  };

  const defaultTargets = { calories: 2000, protein: 170, carbs: 200, fat: 60 };

  function round1(x){ return Math.round((x + Number.EPSILON) * 10) / 10; }
  function escapeHtml(s){ return String(s ?? "").replace(/[&<>"']/g, c => ({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;" }[c])); }
  function csv(s){ const t = String(s ?? ""); return /[",\n]/.test(t) ? `"${t.replace(/"/g,'""')}"` : t; }

  const status = document.getElementById("status");
  function toast(msg) {
    status.textContent = msg;
    setTimeout(() => { if (status.textContent === msg) status.textContent = "Ready."; }, 1400);
  }

  // ---------- Elements ----------
  const video = document.getElementById("video");
  const cameraSelect = document.getElementById("cameraSelect");
  const startBtn = document.getElementById("startBtn");
  const stopBtn = document.getElementById("stopBtn");
  const torchBtn = document.getElementById("torchBtn");

  const barcodeEl = document.getElementById("barcode");
  const lookupBtn = document.getElementById("lookupBtn");

  const productCard = document.getElementById("productCard");
  const prodName = document.getElementById("prodName");
  const prodMeta = document.getElementById("prodMeta");
  const nutriPreview = document.getElementById("nutriPreview");

  const modeEl = document.getElementById("mode");
  const qtyEl = document.getElementById("qty");
  const addBtn = document.getElementById("addBtn");
  const modeHelp = document.getElementById("modeHelp");

  const tCalories = document.getElementById("tCalories");
  const tProtein = document.getElementById("tProtein");
  const tCarbs = document.getElementById("tCarbs");
  const tFat = document.getElementById("tFat");
  const saveTargets = document.getElementById("saveTargets");
  const exportCsv = document.getElementById("exportCsv");
  const clearToday = document.getElementById("clearToday");
  const totalsEl = document.getElementById("totals");
  const logBody = document.getElementById("logBody");

  // ---------- Targets ----------
  const targets = LS.get("targets", defaultTargets);
  tCalories.value = targets.calories;
  tProtein.value = targets.protein;
  tCarbs.value = targets.carbs;
  tFat.value = targets.fat;

  saveTargets.addEventListener("click", () => {
    const t = {
      calories: Number(tCalories.value || 0),
      protein: Number(tProtein.value || 0),
      carbs: Number(tCarbs.value || 0),
      fat: Number(tFat.value || 0)
    };
    LS.set("targets", t);
    render();
    toast("Targets saved.");
  });

  // ---------- Log ----------
  function getLog() { return LS.get(todayKey(), []); }
  function setLog(items) { LS.set(todayKey(), items); }
  function sumLog(items) {
    return items.reduce((acc, it) => {
      acc.calories += it.calories;
      acc.protein += it.protein;
      acc.carbs += it.carbs;
      acc.fat += it.fat;
      return acc;
    }, { calories:0, protein:0, carbs:0, fat:0 });
  }
  function classify(remaining) {
    if (remaining >= 0) return "ok";
    if (remaining > -150) return "warn";
    return "bad";
  }
  function render() {
    const items = getLog();
    const totals = sumLog(items);
    const t = LS.get("targets", defaultTargets);

    const remCals = t.calories - totals.calories;
    const remP = t.protein - totals.protein;
    const remCarbs = t.carbs - totals.carbs;
    const remFat = t.fat - totals.fat;

    totalsEl.innerHTML = [
      `<div class="pill ${classify(remCals)}"><b>Calories</b> ${totals.calories.toFixed(0)} / ${t.calories} (rem ${remCals.toFixed(0)})</div>`,
      `<div class="pill ${classify(remP)}"><b>Protein</b> ${totals.protein.toFixed(1)} / ${t.protein}g (rem ${remP.toFixed(1)}g)</div>`,
      `<div class="pill ${classify(remCarbs)}"><b>Carbs</b> ${totals.carbs.toFixed(1)} / ${t.carbs}g (rem ${remCarbs.toFixed(1)}g)</div>`,
      `<div class="pill ${classify(remFat)}"><b>Fat</b> ${totals.fat.toFixed(1)} / ${t.fat}g (rem ${remFat.toFixed(1)}g)</div>`
    ].join(" ");

    logBody.innerHTML = "";
    items.forEach((it, idx) => {
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td>
          <div style="font-weight:700">${escapeHtml(it.name)}</div>
          <div class="small">${escapeHtml(it.detail)}</div>
        </td>
        <td class="right">${it.calories.toFixed(0)}</td>
        <td class="right">${it.protein.toFixed(1)}</td>
        <td class="right">${it.carbs.toFixed(1)}</td>
        <td class="right">${it.fat.toFixed(1)}</td>
        <td class="right"><button class="ghost" data-del="${idx}" style="padding:8px 10px; font-size:12px;">Delete</button></td>
      `;
      logBody.appendChild(tr);
    });

    logBody.querySelectorAll("button[data-del]").forEach(btn => {
      btn.addEventListener("click", () => {
        const i = Number(btn.getAttribute("data-del"));
        const next = getLog().filter((_, idx) => idx !== i);
        setLog(next);
        render();
      });
    });
  }

  clearToday.addEventListener("click", () => {
    setLog([]);
    render();
    toast("Cleared today.");
  });

  exportCsv.addEventListener("click", () => {
    const items = getLog();
    const header = ["timestamp","name","detail","calories","protein_g","carbs_g","fat_g","barcode","source"].join(",");
    const rows = items.map(it => ([
      it.timestamp,
      csv(it.name),
      csv(it.detail),
      it.calories.toFixed(0),
      it.protein.toFixed(1),
      it.carbs.toFixed(1),
      it.fat.toFixed(1),
      it.barcode || "",
      it.source || ""
    ].join(",")));
    const blob = new Blob([header + "\n" + rows.join("\n")], { type: "text/csv;charset=utf-8" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `${todayKey()}.csv`;
    a.click();
    URL.revokeObjectURL(url);
  });

  // ---------- Open Food Facts Lookup ----------
  let currentFood = null;

  function num(v) { const x = Number(v); return Number.isFinite(x) ? x : null; }
  function guessServingGrams(servingText) {
    if (!servingText) return null;
    const m = servingText.match(/([\d.]+)\s*g/i);
    if (!m) return null;
    const v = Number(m[1]);
    return Number.isFinite(v) ? v : null;
  }

  function parseOFF(product) {
    const n = product.nutriments || {};
    const name = product.product_name || product.abbreviated_product_name || "(Unknown product)";
    const brand = product.brands || "";
    const serving = product.serving_size || "";

    const per100g = {
      kcal: num(n["energy-kcal_100g"]),
      protein: num(n["proteins_100g"]),
      carbs: num(n["carbohydrates_100g"]),
      fat: num(n["fat_100g"])
    };

    const perServing = {
      kcal: num(n["energy-kcal_serving"]),
      protein: num(n["proteins_serving"]),
      carbs: num(n["carbohydrates_serving"]),
      fat: num(n["fat_serving"])
    };

    const hasServing = Object.values(perServing).some(v => Number.isFinite(v) && v > 0);
    const servingGrams = guessServingGrams(serving);

    return { name, brand, servingSizeText: serving, per100g, perServing, hasServing, servingGrams, source: "Open Food Facts" };
  }

  function scaleMacros(m, factor) {
    const safe = (v) => (Number.isFinite(v) ? v : 0);
    return {
      calories: safe(m.kcal) * factor,
      protein: safe(m.protein) * factor,
      carbs: safe(m.carbs) * factor,
      fat: safe(m.fat) * factor
    };
  }

  function computeForQty(foodData, qty, mode) {
    let macros;
    if (mode === "serving") {
      if (foodData.hasServing) {
        macros = scaleMacros(foodData.perServing, qty);
        return { macros, detail: `${qty} serving(s)` };
      }
      macros = scaleMacros(foodData.per100g, qty);
      return { macros, detail: `${qty} x 100g (fallback)` };
    }
    const grams = qty;
    const factor = grams / 100.0;
    macros = scaleMacros(foodData.per100g, factor);
    return { macros, detail: `${grams} g` };
  }

  function updateModeHelp(data) {
    if (!data) return;
    if (modeEl.value === "serving") {
      modeHelp.textContent = data.hasServing
        ? `Serving mode: uses per-serving values (${data.servingSizeText || "1 serving"}).`
        : `Serving mode: per-serving data not available; using per 100g estimate.`;
    } else {
      modeHelp.textContent = `Gram mode: uses per 100g values scaled to grams.`;
    }
  }

  function updatePreview() {
    if (!currentFood) return;
    const qty = Number(qtyEl.value || 0);
    const mode = modeEl.value;

    updateModeHelp(currentFood);
    const { macros, detail } = computeForQty(currentFood, qty, mode);

    nutriPreview.textContent = JSON.stringify({
      item: currentFood.name,
      amount: detail,
      calories_kcal: Math.round(macros.calories),
      protein_g: round1(macros.protein),
      carbs_g: round1(macros.carbs),
      fat_g: round1(macros.fat),
      note: currentFood.hasServing ? "Using serving data when available." : "Serving data not available; using per 100g where needed."
    }, null, 2);
  }

  modeEl.addEventListener("change", updatePreview);
  qtyEl.addEventListener("input", updatePreview);

  async function lookup(barcode) {
    status.textContent = "Looking up barcode in Open Food Facts…";
    productCard.style.display = "none";
    currentFood = null;

    const url = `https://world.openfoodfacts.org/api/v0/product/${encodeURIComponent(barcode)}.json`;
    const res = await fetch(url);
    const data = await res.json();

    if (data.status !== 1) {
      status.textContent =
        "Not found in Open Food Facts.\n" +
        "Try scanning again (closer + better light) or type the barcode.\n" +
        "If you want, I can add a second database fallback.";
      return;
    }

    const parsed = parseOFF(data.product);
    currentFood = { barcode, ...parsed };

    prodName.textContent = parsed.name;
    prodMeta.textContent = [parsed.brand, parsed.servingSizeText].filter(Boolean).join(" • ");
    productCard.style.display = "block";

    updateModeHelp(parsed);
    updatePreview();

    status.textContent = "Found product. Choose serving/grams and tap Add.";
  }

  lookupBtn.addEventListener("click", () => {
    const code = barcodeEl.value.trim();
    if (!code) return toast("Enter a barcode first.");
    lookup(code);
  });

  addBtn.addEventListener("click", () => {
    if (!currentFood) return toast("Lookup a product first.");
    const qty = Number(qtyEl.value || 0);
    if (!Number.isFinite(qty) || qty <= 0) return toast("Enter a quantity > 0.");

    const mode = modeEl.value;
    const { macros, detail } = computeForQty(currentFood, qty, mode);

    const entry = {
      timestamp: new Date().toISOString(),
      name: currentFood.name,
      detail,
      calories: macros.calories,
      protein: macros.protein,
      carbs: macros.carbs,
      fat: macros.fat,
      barcode: currentFood.barcode,
      source: currentFood.source
    };

    const items = getLog();
    items.unshift(entry);
    setLog(items);
    render();
    toast("Added.");
  });

  // ---------- Scanner (Quagga2) ----------
  const Quagga = window.Quagga;
  if (!Quagga) {
    status.textContent = "Quagga failed to load. Check the Quagga <script> tag and redeploy.";
  }

  let scanning = false;
  let lastDecoded = null;
  let torchOn = false;

  async function listCamerasForDropdown() {
    try {
      const devices = await navigator.mediaDevices.enumerateDevices();
      const cams = devices.filter(d => d.kind === "videoinput");
      cameraSelect.innerHTML = "";
      cams.forEach((d, i) => {
        const opt = document.createElement("option");
        opt.value = d.deviceId;
        opt.textContent = d.label || `Camera ${i + 1}`;
        cameraSelect.appendChild(opt);
      });
    } catch { /* ignore */ }
  }

  function supportsTorch() {
    try {
      const track = Quagga.CameraAccess.getActiveTrack?.();
      const caps = track?.getCapabilities?.();
      return !!caps?.torch;
    } catch { return false; }
  }

  async function setTorch(on) {
    try {
      const track = Quagga.CameraAccess.getActiveTrack?.();
      if (!track) return toast("No active camera track.");
      const caps = track.getCapabilities?.();
      if (!caps?.torch) return toast("Flashlight not supported.");

      await track.applyConstraints({ advanced: [{ torch: on }] });
      torchOn = on;
      torchBtn.textContent = `Flashlight: ${torchOn ? "On" : "Off"}`;
    } catch {
      toast("Could not toggle flashlight.");
    }
  }

  torchBtn.addEventListener("click", async () => {
    await setTorch(!torchOn);
  });

  video.addEventListener("click", () => {
    toast("Hold steady 1–2s. Move closer, avoid glare.");
  });

  cameraSelect.addEventListener("change", async () => {
    if (!scanning) return;
    await stopScan();
    await startScan();
  });

  function onDetectedHandler(data) {
    const code = data?.codeResult?.code;
    if (!code) return;
    if (code === lastDecoded) return;

    lastDecoded = code;
    barcodeEl.value = code;
    status.textContent = `Decoded: ${code}\nLooking up…`;
    setTimeout(() => {
  stopScan();
  lookup(code);
}, 250);


  async function startScan() {
    if (!Quagga) return toast("Quagga not loaded.");
    if (scanning) return;

    scanning = true;
    lastDecoded = null;
    status.textContent = "Starting scanner… (Quagga2)";

    await listCamerasForDropdown();
    // Prefer a rear camera deviceId if we can detect it
let chosenId = cameraSelect.value || null;

// If the dropdown is empty/labels are blank (common on iOS), pick the last known rear cam
const lastRear = LS.get("rearCamDeviceId", null);
if (!chosenId && lastRear) chosenId = lastRear;

// Try to auto-pick a rear camera based on label once permissions exist
try {
  const devices = await navigator.mediaDevices.enumerateDevices();
  const cams = devices.filter(d => d.kind === "videoinput");
  const rear = cams.find(d => /back|rear|environment/i.test(d.label));
  if (rear?.deviceId) chosenId = rear.deviceId;
} catch {}


    // Clean any previous run
    try { Quagga.offDetected(onDetectedHandler); } catch {}
    try { Quagga.stop(); } catch {}
    try { Quagga.CameraAccess.release(); } catch {}

    Quagga.init({
      inputStream: {
        type: "LiveStream",
        target: document.getElementById("quaggaTarget"),
        constraints: {
  // iOS sometimes ignores "ideal". "exact" is more forceful.
  facingMode: { exact: "environment" },
  width: { ideal: 1280, min: 640 },
  height: { ideal: 720, min: 480 },
  ...(chosenId ? { deviceId: chosenId } : {})
}

      },
      locator: { patchSize: "medium", halfSample: true },
      locate: true,
      decoder: {
        readers: ["upc_reader", "ean_reader", "ean_8_reader"]
      }
    }, (err) => {
      if (err) {
  // Fallback: try again with "ideal" environment (less strict)
  try {
    await new Promise((resolve, reject) => {
      Quagga.init({
        inputStream: {
          type: "LiveStream",
          target: document.getElementById("quaggaTarget"),
          constraints: {
            facingMode: { ideal: "environment" },
            width: { ideal: 1280, min: 640 },
            height: { ideal: 720, min: 480 },
            ...(chosenId ? { deviceId: chosenId } : {})
          }
        },
        locator: { patchSize: "medium", halfSample: true },
        locate: true,
        decoder: { readers: ["upc_reader", "ean_reader", "ean_8_reader"] }
      }, (err2) => err2 ? reject(err2) : resolve());
    });
  } catch (e2) {
    scanning = false;
    status.textContent =
      "Quagga init error (rear cam): " + (e2?.message || String(e2)) +
      "\nFix: allow camera + refresh. If it keeps choosing selfie cam, we’ll pin deviceId.";
    return;
  }
}


      Quagga.start();
      // Persist the active camera deviceId so restarts don’t flip to selfie cam
try {
  const track = Quagga.CameraAccess.getActiveTrack?.();
  const settings = track?.getSettings?.();
  if (settings?.deviceId) LS.set("rearCamDeviceId", settings.deviceId);
} catch {}

      status.textContent =
        "Scanning… (Quagga2)\n" +
        "Tips: fill the frame with the barcode, avoid glare, hold steady 1–2s.";

      // Torch button if supported
      if (supportsTorch()) {
        torchBtn.style.display = "inline-block";
        torchBtn.textContent = `Flashlight: ${torchOn ? "On" : "Off"}`;
      } else {
        torchBtn.style.display = "none";
        torchOn = false;
      }
    });

    Quagga.onDetected(onDetectedHandler);
  }

  async function stopScan() {
    if (!Quagga) return;
    scanning = false;

    if (torchOn) {
      try { await setTorch(false); } catch {}
    }

    try { Quagga.offDetected(onDetectedHandler); } catch {}
    try { Quagga.stop(); } catch {}
    try { Quagga.CameraAccess.release(); } catch {}

    // Clear Quagga target contents (prevents “black box” leftovers on iOS)
const tgt = document.getElementById("quaggaTarget");
if (tgt) tgt.innerHTML = "";


    status.textContent = "Scanner stopped.";
  }

  startBtn.addEventListener("click", startScan);
  stopBtn.addEventListener("click", stopScan);

  // ---------- Initial render ----------
  render();
</script>
</body>
</html>
