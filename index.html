<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Macro Scan & Log</title>

  <style>
    :root { color-scheme: light; }

    /* San Francisco (Apple) + safe fallbacks */
    body{
      font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", "SF Pro Display", system-ui, sans-serif;
      margin:0; background:#f6f7fb;
    }

    header{ padding:14px 16px; background:#111827; color:#fff; }
    header h1{ font-size:16px; margin:0; }

    main{ padding:16px; max-width:980px; margin:0 auto; }
    .grid{ display:grid; gap:12px; }
    @media (min-width: 900px){ .grid{ grid-template-columns: 1.1fr 0.9fr; } }

    .card{
      background:#fff; border:1px solid #e5e7eb; border-radius:14px; padding:14px;
      box-shadow: 0 10px 30px rgba(0,0,0,.04);
    }

    label{ display:block; font-weight:700; font-size:12px; color:#374151; margin:10px 0 6px; }
    input, select, button{
      width:100%; padding:10px 11px; border:1px solid #d1d5db; border-radius:12px;
      font-size:14px; background:#fff;
    }
    button{ cursor:pointer; border:0; background:#2563eb; color:#fff; font-weight:800; }
    button.secondary{ background:#111827; }
    button.ghost{ background:#f3f4f6; color:#111827; border:1px solid #e5e7eb; font-weight:750; }
    button.danger{ background:#dc2626; }

    .muted{ color:#6b7280; font-size:12px; line-height:1.35; }
    .split{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    .row{ display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
    .row3{ display:grid; grid-template-columns: 1fr 1fr 1fr; gap:10px; }

    .status{
      margin-top:10px; white-space:pre-wrap;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size:12px; background:#f3f4f6; border:1px solid #e5e7eb; padding:10px; border-radius:12px;
    }

    table{ width:100%; border-collapse:collapse; }
    th, td{ text-align:left; padding:10px 8px; border-bottom:1px solid #e5e7eb; font-size:13px; vertical-align:top; }
    th{ font-size:12px; color:#374151; }
    .right{ text-align:right; }
    .small{ font-size:12px; color:#6b7280; }

    .pill{
      display:inline-block; padding:6px 10px; border-radius:999px;
      background:#f3f4f6; border:1px solid #e5e7eb; font-size:12px; margin-right:8px;
    }
    .ok{ background:#ecfdf5; border-color:#10b98133; }
    .warn{ background:#fff7ed; border-color:#f59e0b33; }
    .bad{ background:#fef2f2; border-color:#ef444433; }

    /* Camera */
    .videoWrap{
      position:relative;
      width:100%;
      aspect-ratio: 4 / 3;
      border-radius:14px;
      overflow:hidden;
      background:#111827;
      border:1px solid #111827;
    }
    #quaggaTarget{ position:absolute; inset:0; z-index:3; }
    #quaggaTarget video, #quaggaTarget canvas{
      position:absolute; inset:0; width:100%; height:100%; object-fit:cover;
    }

    .fileBtn{
      display:inline-block; padding:10px 11px; border-radius:12px;
      border:1px solid #e5e7eb; background:#f3f4f6; cursor:pointer; font-weight:800;
      color:#111827;
    }
    .fileBtn input{ display:none; }

    .divider{ height:1px; background:#e5e7eb; margin:12px 0; }

    details{ border:1px solid #e5e7eb; border-radius:12px; padding:10px 12px; background:#fff; }
    details > summary{ cursor:pointer; font-weight:900; color:#111827; }
    .note{ font-size:12px; color:#6b7280; margin-top:6px; }
  </style>
</head>

<body>
<header>
  <h1>Macro Scan & Log (Barcode → Lookup → Verified Macros → Daily Log)</h1>
</header>

<main class="grid">
  <!-- LEFT: Scanner + Lookup -->
  <section class="card">
    <h2 style="margin:0 0 8px 0; font-size:16px;">Scan & add food</h2>
    <div class="muted">
      Best results on iPhone: open in <b>Safari</b> via <b>HTTPS</b> (GitHub Pages). Fill the frame with the barcode, avoid glare, hold steady 1–2s.
    </div>

    <label>Camera</label>
    <div class="videoWrap">
      <div id="quaggaTarget"></div>
    </div>

    <div class="split" style="margin-top:10px;">
      <button id="startBtn" style="max-width:220px;">Start scanner</button>
      <button id="stopBtn" class="ghost" style="max-width:140px;">Stop</button>
      <button id="torchBtn" class="ghost" style="max-width:220px; display:none;">Flashlight: Off</button>

      <label class="fileBtn" style="max-width:240px;">
        Upload barcode photo
        <input id="barcodePhoto" type="file" accept="image/*" />
      </label>

      <select id="cameraSelect" aria-label="Camera selection" style="max-width:280px;"></select>
    </div>

    <label>Barcode (UPC/EAN)</label>
    <div class="row">
      <input id="barcode" placeholder="Scan fills this, or type it" inputmode="numeric" />
      <button id="lookupBtn" class="secondary">Lookup</button>
    </div>

    <div id="productCard" style="display:none; margin-top:12px;">
      <div class="split" style="gap:8px;">
        <span class="pill ok" id="sourcePill">Source: —</span>
        <span class="pill" id="coveragePill" style="display:none;">Coverage: —</span>
      </div>

      <div style="margin-top:10px;">
        <div style="font-weight:900;" id="prodName"></div>
        <div class="small" id="prodMeta"></div>
      </div>

      <label>Serving input</label>
      <div class="row3">
        <select id="mode">
          <option value="serving">By serving</option>
          <option value="grams">By grams</option>
        </select>
        <input id="qty" type="number" min="0" step="0.25" value="1" />
        <button id="addBtn">Add to today</button>
      </div>
      <div class="muted" id="modeHelp" style="margin-top:6px;">—</div>
      <div class="status" id="nutriPreview">—</div>

      <div class="divider"></div>

      <!-- Accuracy / Verification -->
      <details id="verifyPanel">
        <summary>Accuracy: verify / edit macros for this barcode</summary>
        <div class="note">
          If the database is missing/incorrect, enter the macros from the nutrition label. Your saved values will be used next time you scan this barcode on this device.
        </div>

        <label>Serving size text (optional)</label>
        <input id="editServingText" placeholder="e.g., 1 bar (40g)" />

        <div class="row" style="margin-top:6px;">
          <div>
            <label>Serving grams (optional)</label>
            <input id="editServingGrams" type="number" min="0" step="0.1" placeholder="e.g., 40" />
          </div>
          <div>
            <label>Which numbers are you entering?</label>
            <select id="editBasis">
              <option value="serving">Per serving</option>
              <option value="100g">Per 100g</option>
            </select>
          </div>
        </div>

        <div class="row" style="margin-top:6px;">
          <div>
            <label>Calories (kcal)</label>
            <input id="editKcal" type="number" min="0" step="1" />
          </div>
          <div>
            <label>Protein (g)</label>
            <input id="editProtein" type="number" min="0" step="0.1" />
          </div>
        </div>

        <div class="row" style="margin-top:6px;">
          <div>
            <label>Carbs (g)</label>
            <input id="editCarbs" type="number" min="0" step="0.1" />
          </div>
          <div>
            <label>Fat (g)</label>
            <input id="editFat" type="number" min="0" step="0.1" />
          </div>
        </div>

        <div class="split" style="margin-top:10px;">
          <button id="saveOverride" class="ghost" style="max-width:220px;">Save as verified</button>
          <button id="clearOverride" class="danger" style="max-width:220px;">Remove verified data</button>
        </div>

        <div class="status" id="verifyStatus" style="margin-top:10px;">—</div>
      </details>
    </div>

    <div class="status" id="status">Ready.</div>
  </section>

  <!-- RIGHT: Targets + Log -->
  <section class="card">
    <h2 style="margin:0 0 8px 0; font-size:16px;">Today’s targets</h2>

    <div class="row">
      <div>
        <label>Calories target</label>
        <input id="tCalories" type="number" min="0" step="10" value="2000" />
      </div>
      <div>
        <label>Protein target (g)</label>
        <input id="tProtein" type="number" min="0" step="5" value="170" />
      </div>
    </div>
    <div class="row">
      <div>
        <label>Carbs target (g)</label>
        <input id="tCarbs" type="number" min="0" step="5" value="200" />
      </div>
      <div>
        <label>Fat target (g)</label>
        <input id="tFat" type="number" min="0" step="5" value="60" />
      </div>
    </div>

    <div class="split" style="margin-top:10px;">
      <button id="saveTargets" class="ghost" style="max-width:160px;">Save targets</button>
      <button id="exportCsv" class="ghost" style="max-width:160px;">Export CSV</button>
      <button id="clearToday" class="danger" style="max-width:160px;">Clear today</button>
    </div>

    <h3 style="margin:14px 0 6px 0; font-size:14px;">Today totals</h3>
    <div id="totals" class="status">—</div>

    <h3 style="margin:14px 0 6px 0; font-size:14px;">Today log</h3>
    <div style="max-height:380px; overflow:auto; border:1px solid #e5e7eb; border-radius:12px;">
      <table>
        <thead>
          <tr>
            <th>Item</th>
            <th class="right">kcal</th>
            <th class="right">P</th>
            <th class="right">C</th>
            <th class="right">F</th>
            <th></th>
          </tr>
        </thead>
        <tbody id="logBody"></tbody>
      </table>
    </div>

    <div class="muted" style="margin-top:10px;">
      Accuracy tip: for “accurate every time,” use the <b>verify / edit</b> panel once per barcode (from the label). After that, your log will always use your verified macros.
    </div>
  </section>
</main>

<!-- Quagga2 global build -->
<script src="https://cdn.jsdelivr.net/npm/@ericblade/quagga2@1.8.4/dist/quagga.min.js"></script>

<script type="module">
  // ---------------------------
  // Storage helpers
  // ---------------------------
  const LS = {
    get(key, fallback) { try { return JSON.parse(localStorage.getItem(key)) ?? fallback; } catch { return fallback; } },
    set(key, val) { localStorage.setItem(key, JSON.stringify(val)); },
    del(key) { localStorage.removeItem(key); }
  };

  const OVERRIDE_KEY = "barcode_overrides_v1"; // { [barcode]: { servingText, servingGrams, perServing, per100g, updatedAtISO } }

  function getOverrides(){ return LS.get(OVERRIDE_KEY, {}); }
  function setOverrides(map){ LS.set(OVERRIDE_KEY, map); }

  const todayKey = () => {
    const d = new Date();
    const yyyy = d.getFullYear();
    const mm = String(d.getMonth()+1).padStart(2,"0");
    const dd = String(d.getDate()).padStart(2,"0");
    return `log_${yyyy}-${mm}-${dd}`;
  };

  const defaultTargets = { calories: 2000, protein: 170, carbs: 200, fat: 60 };

  // ---------------------------
  // Small utils
  // ---------------------------
  function round1(x){ return Math.round((x + Number.EPSILON) * 10) / 10; }
  function escapeHtml(s){ return String(s ?? "").replace(/[&<>"']/g, c => ({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;" }[c])); }
  function csv(s){ const t = String(s ?? ""); return /[",\n]/.test(t) ? `"${t.replace(/"/g,'""')}"` : t; }
  function num(v) { const x = Number(v); return Number.isFinite(x) ? x : null; }
  function safe(v){ return Number.isFinite(v) ? v : 0; }

  // ---------------------------
  // Elements
  // ---------------------------
  const status = document.getElementById("status");

  const cameraSelect = document.getElementById("cameraSelect");
  const startBtn = document.getElementById("startBtn");
  const stopBtn = document.getElementById("stopBtn");
  const torchBtn = document.getElementById("torchBtn");

  const barcodeEl = document.getElementById("barcode");
  const lookupBtn = document.getElementById("lookupBtn");
  const photoInput = document.getElementById("barcodePhoto");

  const productCard = document.getElementById("productCard");
  const sourcePill = document.getElementById("sourcePill");
  const coveragePill = document.getElementById("coveragePill");
  const prodName = document.getElementById("prodName");
  const prodMeta = document.getElementById("prodMeta");
  const nutriPreview = document.getElementById("nutriPreview");

  const modeEl = document.getElementById("mode");
  const qtyEl = document.getElementById("qty");
  const addBtn = document.getElementById("addBtn");
  const modeHelp = document.getElementById("modeHelp");

  // Verify panel
  const verifyPanel = document.getElementById("verifyPanel");
  const editServingText = document.getElementById("editServingText");
  const editServingGrams = document.getElementById("editServingGrams");
  const editBasis = document.getElementById("editBasis");
  const editKcal = document.getElementById("editKcal");
  const editProtein = document.getElementById("editProtein");
  const editCarbs = document.getElementById("editCarbs");
  const editFat = document.getElementById("editFat");
  const saveOverride = document.getElementById("saveOverride");
  const clearOverride = document.getElementById("clearOverride");
  const verifyStatus = document.getElementById("verifyStatus");

  // Targets + log
  const tCalories = document.getElementById("tCalories");
  const tProtein = document.getElementById("tProtein");
  const tCarbs = document.getElementById("tCarbs");
  const tFat = document.getElementById("tFat");
  const saveTargets = document.getElementById("saveTargets");
  const exportCsvBtn = document.getElementById("exportCsv");
  const clearToday = document.getElementById("clearToday");
  const totalsEl = document.getElementById("totals");
  const logBody = document.getElementById("logBody");

  function toast(msg) {
    status.textContent = msg;
    setTimeout(() => { if (status.textContent === msg) status.textContent = "Ready."; }, 1600);
  }

  // ---------------------------
  // Targets
  // ---------------------------
  const targets = LS.get("targets", defaultTargets);
  tCalories.value = targets.calories;
  tProtein.value = targets.protein;
  tCarbs.value = targets.carbs;
  tFat.value = targets.fat;

  saveTargets.addEventListener("click", () => {
    const t = {
      calories: Number(tCalories.value || 0),
      protein: Number(tProtein.value || 0),
      carbs: Number(tCarbs.value || 0),
      fat: Number(tFat.value || 0)
    };
    LS.set("targets", t);
    render();
    toast("Targets saved.");
  });

  // ---------------------------
  // Log
  // ---------------------------
  function getLog() { return LS.get(todayKey(), []); }
  function setLog(items) { LS.set(todayKey(), items); }
  function sumLog(items) {
    return items.reduce((acc, it) => {
      acc.calories += it.calories;
      acc.protein += it.protein;
      acc.carbs += it.carbs;
      acc.fat += it.fat;
      return acc;
    }, { calories:0, protein:0, carbs:0, fat:0 });
  }
  function classify(remaining) {
    if (remaining >= 0) return "ok";
    if (remaining > -150) return "warn";
    return "bad";
  }
  function render() {
    const items = getLog();
    const totals = sumLog(items);
    const t = LS.get("targets", defaultTargets);

    const remCals = t.calories - totals.calories;
    const remP = t.protein - totals.protein;
    const remCarbs = t.carbs - totals.carbs;
    const remFat = t.fat - totals.fat;

    totalsEl.innerHTML = [
      `<div class="pill ${classify(remCals)}"><b>Calories</b> ${totals.calories.toFixed(0)} / ${t.calories} (rem ${remCals.toFixed(0)})</div>`,
      `<div class="pill ${classify(remP)}"><b>Protein</b> ${totals.protein.toFixed(1)} / ${t.protein}g (rem ${remP.toFixed(1)}g)</div>`,
      `<div class="pill ${classify(remCarbs)}"><b>Carbs</b> ${totals.carbs.toFixed(1)} / ${t.carbs}g (rem ${remCarbs.toFixed(1)}g)</div>`,
      `<div class="pill ${classify(remFat)}"><b>Fat</b> ${totals.fat.toFixed(1)} / ${t.fat}g (rem ${remFat.toFixed(1)}g)</div>`
    ].join(" ");

    logBody.innerHTML = "";
    items.forEach((it, idx) => {
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td>
          <div style="font-weight:900">${escapeHtml(it.name)}</div>
          <div class="small">${escapeHtml(it.detail)}</div>
          <div class="small">${escapeHtml(it.source || "")}${it.barcode ? " • " + escapeHtml(it.barcode) : ""}</div>
        </td>
        <td class="right">${it.calories.toFixed(0)}</td>
        <td class="right">${it.protein.toFixed(1)}</td>
        <td class="right">${it.carbs.toFixed(1)}</td>
        <td class="right">${it.fat.toFixed(1)}</td>
        <td class="right"><button class="ghost" data-del="${idx}" style="padding:8px 10px; font-size:12px;">Delete</button></td>
      `;
      logBody.appendChild(tr);
    });

    logBody.querySelectorAll("button[data-del]").forEach(btn => {
      btn.addEventListener("click", () => {
        const i = Number(btn.getAttribute("data-del"));
        const next = getLog().filter((_, idx) => idx !== i);
        setLog(next);
        render();
      });
    });
  }

  clearToday.addEventListener("click", () => {
    setLog([]);
    render();
    toast("Cleared today.");
  });

  exportCsvBtn.addEventListener("click", () => {
    const items = getLog();
    const header = ["timestamp","name","detail","calories","protein_g","carbs_g","fat_g","barcode","source"].join(",");
    const rows = items.map(it => ([
      it.timestamp,
      csv(it.name),
      csv(it.detail),
      it.calories.toFixed(0),
      it.protein.toFixed(1),
      it.carbs.toFixed(1),
      it.fat.toFixed(1),
      it.barcode || "",
      it.source || ""
    ].join(",")));
    const blob = new Blob([header + "\n" + rows.join("\n")], { type: "text/csv;charset=utf-8" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `${todayKey()}.csv`;
    a.click();
    URL.revokeObjectURL(url);
  });

  // ---------------------------
  // Food data model
  // ---------------------------
  let currentFood = null; // { barcode, name, brand, servingSizeText, servingGrams, per100g, perServing, source, accuracyNote }

  function guessServingGrams(servingText) {
    if (!servingText) return null;
    const m = servingText.match(/([\d.]+)\s*g/i);
    if (!m) return null;
    const v = Number(m[1]);
    return Number.isFinite(v) ? v : null;
  }

  function parseOFF(product) {
    const n = product.nutriments || {};
    const name = product.product_name || product.abbreviated_product_name || "(Unknown product)";
    const brand = product.brands || "";
    const serving = product.serving_size || "";

    const per100g = {
      kcal: num(n["energy-kcal_100g"]),
      protein: num(n["proteins_100g"]),
      carbs: num(n["carbohydrates_100g"]),
      fat: num(n["fat_100g"])
    };

    const perServing = {
      kcal: num(n["energy-kcal_serving"]),
      protein: num(n["proteins_serving"]),
      carbs: num(n["carbohydrates_serving"]),
      fat: num(n["fat_serving"])
    };

    const hasServing = Object.values(perServing).some(v => Number.isFinite(v) && v > 0);
    const has100g = Object.values(per100g).some(v => Number.isFinite(v) && v > 0);

    const servingGrams = guessServingGrams(serving);

    return {
      name,
      brand,
      servingSizeText: serving,
      servingGrams,
      per100g,
      perServing,
      hasServing,
      has100g,
      source: "Open Food Facts"
    };
  }

  function applyOverride(barcode, baseFood) {
    const overrides = getOverrides();
    const ov = overrides[barcode];
    if (!ov) return baseFood;

    const merged = { ...baseFood };
    merged.servingSizeText = ov.servingText ?? merged.servingSizeText;
    merged.servingGrams = Number.isFinite(ov.servingGrams) ? ov.servingGrams : merged.servingGrams;

    if (ov.perServing) merged.perServing = { ...merged.perServing, ...ov.perServing };
    if (ov.per100g) merged.per100g = { ...merged.per100g, ...ov.per100g };

    // recompute flags
    merged.hasServing = Object.values(merged.perServing).some(v => Number.isFinite(v) && v > 0);
    merged.has100g = Object.values(merged.per100g).some(v => Number.isFinite(v) && v > 0);

    merged.source = "Verified (You)";
    merged.accuracyNote = `Verified on ${new Date(ov.updatedAtISO).toLocaleString()}`;
    return merged;
  }

  function scaleMacros(macros, factor) {
    return {
      calories: safe(macros.kcal) * factor,
      protein: safe(macros.protein) * factor,
      carbs: safe(macros.carbs) * factor,
      fat: safe(macros.fat) * factor
    };
  }

  function computeForQty(foodData, qty, mode) {
    if (mode === "serving") {
      if (foodData.hasServing) {
        return { macros: scaleMacros(foodData.perServing, qty), detail: `${qty} serving(s)` };
      }
      // fallback if we only have per100g
      return { macros: scaleMacros(foodData.per100g, qty), detail: `${qty} × 100g (fallback)` };
    }

    // grams mode: use per100g scaled
    const grams = qty;
    const factor = grams / 100.0;
    return { macros: scaleMacros(foodData.per100g, factor), detail: `${grams} g` };
  }

  function updateModeHelp(data) {
    if (!data) return;
    if (modeEl.value === "serving") {
      modeHelp.textContent = data.hasServing
        ? `Serving mode: uses per-serving values (${data.servingSizeText || "1 serving"}).`
        : `Serving mode: per-serving data not available; using per 100g estimate.`;
    } else {
      modeHelp.textContent = `Gram mode: uses per 100g values scaled to grams.`;
    }
  }

  function updatePreview() {
    if (!currentFood) return;
    const qty = Number(qtyEl.value || 0);
    const mode = modeEl.value;
    updateModeHelp(currentFood);

    const { macros, detail } = computeForQty(currentFood, qty, mode);
    nutriPreview.textContent = JSON.stringify({
      item: currentFood.name,
      barcode: currentFood.barcode,
      amount: detail,
      calories_kcal: Math.round(macros.calories),
      protein_g: round1(macros.protein),
      carbs_g: round1(macros.carbs),
      fat_g: round1(macros.fat),
      source: currentFood.source,
      note: currentFood.accuracyNote || ""
    }, null, 2);
  }

  modeEl.addEventListener("change", updatePreview);
  qtyEl.addEventListener("input", updatePreview);

  // ---------------------------
  // Lookup (Open Food Facts + Verified override)
  // ---------------------------
  async function lookup(barcode) {
    status.textContent = "Looking up barcode…";
    productCard.style.display = "none";
    currentFood = null;

    // If user has a verified override, we still fetch OFF for name/brand,
    // but the macros will be replaced by the verified values.
    const url = `https://world.openfoodfacts.org/api/v0/product/${encodeURIComponent(barcode)}.json`;

    let parsed = null;

    try {
      const res = await fetch(url);
      const data = await res.json();

      if (data.status === 1) {
        parsed = parseOFF(data.product);
      }
    } catch {
      // ignore fetch errors; we can still use verified data if present
    }

    // Build base
    const base = parsed ?? {
      name: "(Unknown product)",
      brand: "",
      servingSizeText: "",
      servingGrams: null,
      per100g: { kcal:null, protein:null, carbs:null, fat:null },
      perServing: { kcal:null, protein:null, carbs:null, fat:null },
      hasServing: false,
      has100g: false,
      source: parsed ? "Open Food Facts" : "No database result"
    };

    // Apply verified override if exists
    const finalFood = applyOverride(barcode, base);
    finalFood.barcode = barcode;

    currentFood = finalFood;

    // UI
    prodName.textContent = finalFood.name;
    prodMeta.textContent = [finalFood.brand, finalFood.servingSizeText].filter(Boolean).join(" • ");

    sourcePill.textContent = `Source: ${finalFood.source}`;

    // Coverage pill (helps you spot missing macros)
    const hasAll100g = ["kcal","protein","carbs","fat"].every(k => Number.isFinite(finalFood.per100g?.[k]) && finalFood.per100g[k] >= 0);
    const hasAllServing = ["kcal","protein","carbs","fat"].every(k => Number.isFinite(finalFood.perServing?.[k]) && finalFood.perServing[k] >= 0);

    coveragePill.style.display = "inline-block";
    coveragePill.textContent = `Coverage: ${hasAllServing ? "Per serving ✓" : "Per serving —"} • ${hasAll100g ? "Per 100g ✓" : "Per 100g —"}`;

    productCard.style.display = "block";
    updateModeHelp(finalFood);
    updatePreview();

    // Fill verify panel inputs based on override (if any)
    hydrateVerifyPanel(finalFood);

    if (finalFood.source === "Verified (You)") {
      status.textContent = `Using verified macros for ${barcode}.`;
    } else if (parsed) {
      status.textContent = "Found product. (Tip: verify if you want guaranteed accuracy.)";
    } else {
      status.textContent = "Not found in database. Use the verify/edit panel to enter label macros.";
      verifyPanel.open = true;
    }
  }

  lookupBtn.addEventListener("click", () => {
    const code = barcodeEl.value.trim();
    if (!code) return toast("Enter a barcode first.");
    lookup(code);
  });

  // ---------------------------
  // Add to today
  // ---------------------------
  addBtn.addEventListener("click", () => {
    if (!currentFood) return toast("Lookup a product first.");
    const qty = Number(qtyEl.value || 0);
    if (!Number.isFinite(qty) || qty <= 0) return toast("Enter a quantity > 0.");

    const mode = modeEl.value;
    const { macros, detail } = computeForQty(currentFood, qty, mode);

    // If macros are all zero because nothing exists, warn
    const nonZero = macros.calories || macros.protein || macros.carbs || macros.fat;
    if (!nonZero) {
      toast("No macro data available yet. Use verify/edit to enter label macros.");
      verifyPanel.open = true;
      return;
    }

    const entry = {
      timestamp: new Date().toISOString(),
      name: currentFood.name,
      detail,
      calories: macros.calories,
      protein: macros.protein,
      carbs: macros.carbs,
      fat: macros.fat,
      barcode: currentFood.barcode,
      source: currentFood.source
    };

    const items = getLog();
    items.unshift(entry);
    setLog(items);
    render();
    toast("Added.");
  });

  // ---------------------------
  // Verify/edit macros (local overrides)
  // ---------------------------
  function hydrateVerifyPanel(food) {
    const overrides = getOverrides();
    const ov = overrides[food.barcode];

    // Show current source + hint
    const lines = [];
    lines.push(`Current source: ${food.source}`);
    if (food.accuracyNote) lines.push(food.accuracyNote);

    // Show current stored values (best available)
    lines.push("");
    lines.push("Current macro values (for reference):");
    lines.push(`Per serving: kcal=${food.perServing?.kcal ?? "—"}, P=${food.perServing?.protein ?? "—"}, C=${food.perServing?.carbs ?? "—"}, F=${food.perServing?.fat ?? "—"}`);
    lines.push(`Per 100g:    kcal=${food.per100g?.kcal ?? "—"}, P=${food.per100g?.protein ?? "—"}, C=${food.per100g?.carbs ?? "—"}, F=${food.per100g?.fat ?? "—"}`);

    verifyStatus.textContent = lines.join("\n");

    // Fill fields: if override exists, prefer it; else blank (user fills from label)
    editServingText.value = ov?.servingText ?? (food.servingSizeText || "");
    editServingGrams.value = Number.isFinite(ov?.servingGrams) ? ov.servingGrams : (Number.isFinite(food.servingGrams) ? food.servingGrams : "");

    // Basis default: per serving if we have serving text, otherwise per 100g
    editBasis.value = (food.servingSizeText || food.hasServing) ? "serving" : "100g";

    // Clear macro inputs (user enters from label)
    editKcal.value = "";
    editProtein.value = "";
    editCarbs.value = "";
    editFat.value = "";
  }

  saveOverride.addEventListener("click", () => {
    if (!currentFood?.barcode) return toast("Lookup a product first.");

    const basis = editBasis.value;
    const kcal = num(editKcal.value);
    const p = num(editProtein.value);
    const c = num(editCarbs.value);
    const f = num(editFat.value);

    // Require all 4 for "accurate every macro"
    if (![kcal,p,c,f].every(v => Number.isFinite(v) && v >= 0)) {
      toast("Please enter Calories, Protein, Carbs, and Fat (all 4).");
      return;
    }

    const overrides = getOverrides();
    const existing = overrides[currentFood.barcode] || {};

    const servingText = (editServingText.value || "").trim();
    const servingGrams = num(editServingGrams.value);

    const next = {
      servingText: servingText || existing.servingText || "",
      servingGrams: Number.isFinite(servingGrams) ? servingGrams : (Number.isFinite(existing.servingGrams) ? existing.servingGrams : null),
      perServing: existing.perServing || null,
      per100g: existing.per100g || null,
      updatedAtISO: new Date().toISOString()
    };

    if (basis === "serving") {
      next.perServing = { kcal, protein:p, carbs:c, fat:f };
    } else {
      next.per100g = { kcal, protein:p, carbs:c, fat:f };
    }

    // If they entered per serving AND also provided serving grams,
    // we can auto-compute per100g for better grams-mode accuracy (and vice versa).
    if (basis === "serving" && Number.isFinite(next.servingGrams) && next.servingGrams > 0) {
      const factor = 100.0 / next.servingGrams;
      next.per100g = {
        kcal: round1(kcal * factor),
        protein: round1(p * factor),
        carbs: round1(c * factor),
        fat: round1(f * factor)
      };
    }
    if (basis === "100g" && Number.isFinite(next.servingGrams) && next.servingGrams > 0) {
      const factor = next.servingGrams / 100.0;
      next.perServing = {
        kcal: round1(kcal * factor),
        protein: round1(p * factor),
        carbs: round1(c * factor),
        fat: round1(f * factor)
      };
    }

    overrides[currentFood.barcode] = next;
    setOverrides(overrides);

    toast("Saved verified macros.");
    // Re-run lookup to apply the verified override to UI immediately
    lookup(currentFood.barcode);
  });

  clearOverride.addEventListener("click", () => {
    if (!currentFood?.barcode) return toast("Lookup a product first.");

    const overrides = getOverrides();
    if (overrides[currentFood.barcode]) {
      delete overrides[currentFood.barcode];
      setOverrides(overrides);
      toast("Removed verified data.");
      lookup(currentFood.barcode);
    } else {
      toast("No verified data to remove.");
    }
  });

  // ---------------------------
  // Photo upload barcode decode (Quagga.decodeSingle)
  // ---------------------------
  photoInput.addEventListener("change", async (e) => {
    const file = e.target.files?.[0];
    if (!file) return;

    const Quagga = window.Quagga;
    if (!Quagga) {
      toast("Scanner library not loaded.");
      e.target.value = "";
      return;
    }

    status.textContent = "Decoding barcode from photo…";

    const url = URL.createObjectURL(file);

    Quagga.decodeSingle({
      src: url,
      numOfWorkers: 0,
      locate: true,
      decoder: { readers: ["upc_reader", "ean_reader", "ean_8_reader"] }
    }, (result) => {
      URL.revokeObjectURL(url);

      const code = result?.codeResult?.code;
      if (!code) {
        status.textContent =
          "Couldn’t decode that photo.\nTips: crop tighter to barcode, brighter light, avoid blur/glare.";
        e.target.value = "";
        return;
      }

      barcodeEl.value = code;
      status.textContent = `Decoded from photo: ${code}\nLooking up…`;
      lookup(code);

      // allow re-upload of same file
      e.target.value = "";
    });
  });

  // ---------------------------
  // Scanner (Quagga2) with iPhone-friendly restart + rear-camera persistence
  // ---------------------------
  const Quagga = window.Quagga;
  if (!Quagga) status.textContent = "Quagga failed to load. Check CDN + redeploy.";

  let scanning = false;
  let lastDecoded = null;
  let torchOn = false;

  async function listCamerasForDropdown() {
    try {
      const devices = await navigator.mediaDevices.enumerateDevices();
      const cams = devices.filter(d => d.kind === "videoinput");
      cameraSelect.innerHTML = "";
      cams.forEach((d, i) => {
        const opt = document.createElement("option");
        opt.value = d.deviceId;
        opt.textContent = d.label || `Camera ${i + 1}`;
        cameraSelect.appendChild(opt);
      });

      const savedRear = LS.get("rearCamDeviceId", null);
      if (savedRear) cameraSelect.value = savedRear;
    } catch { /* ignore */ }
  }

  function supportsTorch() {
    try {
      const track = Quagga.CameraAccess.getActiveTrack?.();
      const caps = track?.getCapabilities?.();
      return !!caps?.torch;
    } catch { return false; }
  }

  async function setTorch(on) {
    try {
      const track = Quagga.CameraAccess.getActiveTrack?.();
      if (!track) return toast("No active camera track.");
      const caps = track.getCapabilities?.();
      if (!caps?.torch) return toast("Flashlight not supported.");

      await track.applyConstraints({ advanced: [{ torch: on }] });
      torchOn = on;
      torchBtn.textContent = `Flashlight: ${torchOn ? "On" : "Off"}`;
    } catch {
      toast("Could not toggle flashlight.");
    }
  }

  torchBtn.addEventListener("click", async () => { await setTorch(!torchOn); });

  function onDetectedHandler(data) {
    const code = data?.codeResult?.code;
    if (!code) return;
    if (code === lastDecoded) return;
    lastDecoded = code;

    barcodeEl.value = code;
    status.textContent = `Decoded: ${code}\nLooking up…`;

    // Delay helps avoid iOS black screen on quick restart
    setTimeout(() => {
      stopScan();
      lookup(code);
    }, 250);
  }

  cameraSelect.addEventListener("change", async () => {
    if (!scanning) return;
    await stopScan();
    await startScan();
  });

  async function startScan() {
    if (!Quagga) return toast("Quagga not loaded.");
    if (scanning) return;

    scanning = true;
    lastDecoded = null;
    status.textContent = "Starting scanner… (Quagga2)";

    await listCamerasForDropdown();

    // Prefer saved rear camera deviceId if available
    let chosenId = cameraSelect.value || null;
    const savedRear = LS.get("rearCamDeviceId", null);
    if (savedRear) chosenId = savedRear;

    // Hard reset before init (prevents black)
    try { Quagga.offDetected(onDetectedHandler); } catch {}
    try { Quagga.stop(); } catch {}
    try { Quagga.CameraAccess.release(); } catch {}

    const targetEl = document.getElementById("quaggaTarget");
    if (targetEl) targetEl.innerHTML = "";

    Quagga.init({
      inputStream: {
        type: "LiveStream",
        target: targetEl,
        constraints: {
          facingMode: { ideal: "environment" },
          width: { ideal: 1280, min: 640 },
          height: { ideal: 720, min: 480 },
          ...(chosenId ? { deviceId: chosenId } : {})
        }
      },
      locator: { patchSize: "medium", halfSample: true },
      locate: true,
      decoder: { readers: ["upc_reader", "ean_reader", "ean_8_reader"] }
    }, (err) => {
      if (err) {
        scanning = false;
        status.textContent =
          "Scanner error:\n" + (err?.message || String(err)) +
          "\n\nFixes:\n- iPhone Settings → Safari → Camera = Allow\n- Open in Safari (not Instagram/Google app browser)\n- Reload with ?v=NEW to bust cache";
        return;
      }

      Quagga.start();

      // Save active deviceId to prevent rear→front flip on restart
      try {
        const track = Quagga.CameraAccess.getActiveTrack?.();
        const settings = track?.getSettings?.();
        if (settings?.deviceId) LS.set("rearCamDeviceId", settings.deviceId);
      } catch {}

      if (supportsTorch()) {
        torchBtn.style.display = "inline-block";
        torchBtn.textContent = `Flashlight: ${torchOn ? "On" : "Off"}`;
      } else {
        torchBtn.style.display = "none";
        torchOn = false;
      }

      status.textContent =
        "Scanning… (Quagga2)\n" +
        "Tips: fill the frame with the barcode, avoid glare, hold steady 1–2s.";
    });

    Quagga.onDetected(onDetectedHandler);
  }

  async function stopScan() {
    if (!Quagga) return;

    scanning = false;

    if (torchOn) {
      try { await setTorch(false); } catch {}
    }

    try { Quagga.offDetected(onDetectedHandler); } catch {}
    try { Quagga.stop(); } catch {}
    try { Quagga.CameraAccess.release(); } catch {}

    // Clear injected elements to prevent “black box” on iOS restarts
    const tgt = document.getElementById("quaggaTarget");
    if (tgt) tgt.innerHTML = "";

    status.textContent = "Scanner stopped.";
  }

  startBtn.addEventListener("click", startScan);
  stopBtn.addEventListener("click", stopScan);

  // ---------------------------
  // Initial render
  // ---------------------------
  render();
</script>
</body>
</html>
