<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Macro Scan & Log</title>

  <style>
    :root { color-scheme: light; }

    /* San Francisco (Apple) + safe fallbacks */
    body{
      font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", "SF Pro Display", system-ui, sans-serif;
      margin:0; background:#f6f7fb;
    }

    header{ padding:14px 16px; background:#111827; color:#fff; }
    header h1{ font-size:16px; margin:0; }

    main{ padding:16px; max-width:1100px; margin:0 auto; }
    .grid{ display:grid; gap:12px; }
    @media (min-width: 980px){ .grid{ grid-template-columns: 1.15fr 0.85fr; } }

    .card{
      background:#fff; border:1px solid #e5e7eb; border-radius:14px; padding:14px;
      box-shadow: 0 10px 30px rgba(0,0,0,.04);
    }

    h2{ margin:0 0 8px 0; font-size:16px; }
    h3{ margin:14px 0 6px 0; font-size:14px; }

    label{ display:block; font-weight:800; font-size:12px; color:#374151; margin:10px 0 6px; }
    input, select, button, textarea{
      width:100%; padding:10px 11px; border:1px solid #d1d5db; border-radius:12px;
      font-size:14px; background:#fff;
      box-sizing: border-box;
    }
    textarea{ min-height: 84px; resize: vertical; }
    button{ cursor:pointer; border:0; background:#2563eb; color:#fff; font-weight:900; }
    button.secondary{ background:#111827; }
    button.ghost{ background:#f3f4f6; color:#111827; border:1px solid #e5e7eb; font-weight:850; }
    button.danger{ background:#dc2626; }

    .muted{ color:#6b7280; font-size:12px; line-height:1.35; }
    .split{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    .row{ display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
    .row3{ display:grid; grid-template-columns: 1fr 1fr 1fr; gap:10px; }
    .row4{ display:grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap:10px; }

    .status{
      margin-top:10px; white-space:pre-wrap;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size:12px; background:#f3f4f6; border:1px solid #e5e7eb; padding:10px; border-radius:12px;
    }

    table{ width:100%; border-collapse:collapse; }
    th, td{ text-align:left; padding:10px 8px; border-bottom:1px solid #e5e7eb; font-size:13px; vertical-align:top; }
    th{ font-size:12px; color:#374151; }
    .right{ text-align:right; }
    .small{ font-size:12px; color:#6b7280; }

    .pill{
      display:inline-block; padding:6px 10px; border-radius:999px;
      background:#f3f4f6; border:1px solid #e5e7eb; font-size:12px; margin-right:8px;
    }
    .ok{ background:#ecfdf5; border-color:#10b98133; }
    .warn{ background:#fff7ed; border-color:#f59e0b33; }
    .bad{ background:#fef2f2; border-color:#ef444433; }

    /* Camera */
    .videoWrap{
      position:relative;
      width:100%;
      aspect-ratio: 4 / 3;
      border-radius:14px;
      overflow:hidden;
      background:#111827;
      border:1px solid #111827;
    }
    #quaggaTarget{ position:absolute; inset:0; z-index:3; }
    #quaggaTarget video, #quaggaTarget canvas{
      position:absolute; inset:0; width:100%; height:100%; object-fit:cover;
    }

    .fileBtn{
      display:inline-block; padding:10px 11px; border-radius:12px;
      border:1px solid #e5e7eb; background:#f3f4f6; cursor:pointer; font-weight:900;
      color:#111827;
      user-select:none;
    }
    .fileBtn input{ display:none; }

    .divider{ height:1px; background:#e5e7eb; margin:12px 0; }

    details{ border:1px solid #e5e7eb; border-radius:12px; padding:10px 12px; background:#fff; }
    details > summary{ cursor:pointer; font-weight:950; color:#111827; }

    .twoCards{ display:grid; gap:12px; }
    @media (min-width: 980px){
      .twoCards{ grid-template-columns: 1fr 1fr; }
    }
  </style>
</head>

<body>
<header>
  <h1>Macro Scan & Log (Scan • Link • Verified Macros • Workouts)</h1>
</header>

<main class="grid">
  <!-- LEFT: Food input -->
  <section class="card">
    <h2>Foods</h2>
    <div class="muted">
      Best on iPhone: open in <b>Safari</b> via <b>HTTPS</b> (GitHub Pages). Fill the frame with barcode, avoid glare, hold steady 1–2s.
    </div>

    <label>Camera</label>
    <div class="videoWrap">
      <div id="quaggaTarget"></div>
    </div>

    <div class="split" style="margin-top:10px;">
      <button id="startBtn" style="max-width:220px;">Start scanner</button>
      <button id="stopBtn" class="ghost" style="max-width:140px;">Stop</button>
      <button id="torchBtn" class="ghost" style="max-width:220px; display:none;">Flashlight: Off</button>

      <label class="fileBtn" style="max-width:260px;">
        Upload barcode photo
        <input id="barcodePhoto" type="file" accept="image/*" />
      </label>

      <select id="cameraSelect" aria-label="Camera selection" style="max-width:280px;"></select>
    </div>

    <div class="twoCards" style="margin-top:12px;">
      <div>
        <label>Barcode (UPC/EAN)</label>
        <div class="row">
          <input id="barcode" placeholder="Scan fills this, or type it" inputmode="numeric" />
          <button id="lookupBtn" class="secondary">Lookup</button>
        </div>
        <div class="muted" style="margin-top:6px;">If found, you can add by serving or grams.</div>
      </div>

      <div>
        <label>Add from link</label>
        <div class="row">
          <input id="linkInput" placeholder="Paste a product link (OFF link works best)" />
          <button id="linkLookupBtn" class="secondary">Detect & lookup</button>
        </div>
        <div class="muted" style="margin-top:6px;">
          Works best with Open Food Facts links, or any link that contains a barcode number.
          If we can’t extract a barcode due to website restrictions, use the Verify/Edit panel below.
        </div>
      </div>
    </div>

    <div id="productCard" style="display:none; margin-top:12px;">
      <div class="split" style="gap:8px;">
        <span class="pill ok" id="sourcePill">Source: —</span>
        <span class="pill" id="coveragePill" style="display:none;">Coverage: —</span>
      </div>

      <div style="margin-top:10px;">
        <div style="font-weight:950;" id="prodName"></div>
        <div class="small" id="prodMeta"></div>
      </div>

      <label>Serving input</label>
      <div class="row3">
        <select id="mode">
          <option value="serving">By serving</option>
          <option value="grams">By grams</option>
        </select>
        <input id="qty" type="number" min="0" step="0.25" value="1" />
        <button id="addBtn">Add to today</button>
      </div>
      <div class="muted" id="modeHelp" style="margin-top:6px;">—</div>
      <div class="status" id="nutriPreview">—</div>

      <div class="divider"></div>

      <!-- Accuracy / Verification -->
      <details id="verifyPanel">
        <summary>Accuracy: verify / edit macros for this barcode</summary>
        <div class="muted" style="margin-top:6px;">
          For “accurate every macro,” enter the nutrition label once and save. Your verified values will be used next time you scan this barcode on this device.
        </div>

        <label>Serving size text (optional)</label>
        <input id="editServingText" placeholder="e.g., 1 bar (40g)" />

        <div class="row" style="margin-top:6px;">
          <div>
            <label>Serving grams (optional)</label>
            <input id="editServingGrams" type="number" min="0" step="0.1" placeholder="e.g., 40" />
          </div>
          <div>
            <label>Which numbers are you entering?</label>
            <select id="editBasis">
              <option value="serving">Per serving</option>
              <option value="100g">Per 100g</option>
            </select>
          </div>
        </div>

        <div class="row" style="margin-top:6px;">
          <div>
            <label>Calories (kcal)</label>
            <input id="editKcal" type="number" min="0" step="1" />
          </div>
          <div>
            <label>Protein (g)</label>
            <input id="editProtein" type="number" min="0" step="0.1" />
          </div>
        </div>

        <div class="row" style="margin-top:6px;">
          <div>
            <label>Carbs (g)</label>
            <input id="editCarbs" type="number" min="0" step="0.1" />
          </div>
          <div>
            <label>Fat (g)</label>
            <input id="editFat" type="number" min="0" step="0.1" />
          </div>
        </div>

        <div class="split" style="margin-top:10px;">
          <button id="saveOverride" class="ghost" style="max-width:220px;">Save as verified</button>
          <button id="clearOverride" class="danger" style="max-width:220px;">Remove verified data</button>
        </div>

        <div class="status" id="verifyStatus" style="margin-top:10px;">—</div>
      </details>
    </div>

    <div class="status" id="status">Ready.</div>
  </section>

  <!-- RIGHT: Targets + Today + Workouts -->
  <section class="card">
    <h2>Today</h2>

    <h3>Targets</h3>
    <div class="row">
      <div>
        <label>Calories target</label>
        <input id="tCalories" type="number" min="0" step="10" value="2000" />
      </div>
      <div>
        <label>Protein target (g)</label>
        <input id="tProtein" type="number" min="0" step="5" value="170" />
      </div>
    </div>
    <div class="row">
      <div>
        <label>Carbs target (g)</label>
        <input id="tCarbs" type="number" min="0" step="5" value="200" />
      </div>
      <div>
        <label>Fat target (g)</label>
        <input id="tFat" type="number" min="0" step="5" value="60" />
      </div>
    </div>

    <div class="split" style="margin-top:10px;">
      <button id="saveTargets" class="ghost" style="max-width:160px;">Save</button>
      <button id="exportCsv" class="ghost" style="max-width:160px;">Export CSV</button>
      <button id="clearToday" class="danger" style="max-width:160px;">Clear day</button>
    </div>

    <h3>Totals</h3>
    <div id="totals" class="status">—</div>

    <h3>Workout log</h3>
    <div class="row3">
      <select id="workoutType">
        <option value="Strength">Strength</option>
        <option value="Cardio">Cardio</option>
        <option value="Sports">Sports</option>
        <option value="Other">Other</option>
      </select>
      <select id="muscleGroup">
        <option value="Full Body">Full Body</option>
        <option value="Chest">Chest</option>
        <option value="Back">Back</option>
        <option value="Shoulders">Shoulders</option>
        <option value="Arms">Arms</option>
        <option value="Legs">Legs</option>
        <option value="Glutes">Glutes</option>
        <option value="Core">Core</option>
        <option value="Cardio/Conditioning">Cardio/Conditioning</option>
      </select>
      <input id="workoutCals" type="number" min="0" step="5" placeholder="Calories burned" />
    </div>

    <div class="row" style="margin-top:10px;">
      <input id="workoutNotes" placeholder="Notes (optional): e.g., Push day, 45 min, PRs..." />
      <button id="addWorkout" class="secondary">Add workout</button>
    </div>

    <div style="max-height:170px; overflow:auto; border:1px solid #e5e7eb; border-radius:12px; margin-top:10px;">
      <table>
        <thead>
          <tr>
            <th>Workout</th>
            <th class="right">Burn</th>
            <th></th>
          </tr>
        </thead>
        <tbody id="workoutBody"></tbody>
      </table>
    </div>

    <h3>Food log</h3>
    <div style="max-height:260px; overflow:auto; border:1px solid #e5e7eb; border-radius:12px;">
      <table>
        <thead>
          <tr>
            <th>Item</th>
            <th class="right">kcal</th>
            <th class="right">P</th>
            <th class="right">C</th>
            <th class="right">F</th>
            <th></th>
          </tr>
        </thead>
        <tbody id="logBody"></tbody>
      </table>
    </div>

    <div class="muted" style="margin-top:10px;">
      “MyFitnessPal-style” accuracy: use <b>Verify/Edit</b> once per barcode (from the label). After that, it’s accurate every scan on this device.
    </div>
  </section>
</main>

<!-- Quagga2 global build -->
<script src="https://cdn.jsdelivr.net/npm/@ericblade/quagga2@1.8.4/dist/quagga.min.js"></script>

<script type="module">
  // ---------------------------
  // Storage helpers
  // ---------------------------
  const LS = {
    get(key, fallback) { try { return JSON.parse(localStorage.getItem(key)) ?? fallback; } catch { return fallback; } },
    set(key, val) { localStorage.setItem(key, JSON.stringify(val)); },
  };

  const OVERRIDE_KEY = "barcode_overrides_v1"; // { [barcode]: {...} }
  function getOverrides(){ return LS.get(OVERRIDE_KEY, {}); }
  function setOverrides(map){ LS.set(OVERRIDE_KEY, map); }

  const todayKey = (prefix) => {
    const d = new Date();
    const yyyy = d.getFullYear();
    const mm = String(d.getMonth()+1).padStart(2,"0");
    const dd = String(d.getDate()).padStart(2,"0");
    return `${prefix}_${yyyy}-${mm}-${dd}`;
  };

  const FOOD_KEY = () => todayKey("foods");
  const WORKOUT_KEY = () => todayKey("workouts");

  const defaultTargets = { calories: 2000, protein: 170, carbs: 200, fat: 60 };

  // ---------------------------
  // Utils
  // ---------------------------
  function round1(x){ return Math.round((x + Number.EPSILON) * 10) / 10; }
  function escapeHtml(s){ return String(s ?? "").replace(/[&<>"']/g, c => ({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;" }[c])); }
  function csv(s){ const t = String(s ?? ""); return /[",\n]/.test(t) ? `"${t.replace(/"/g,'""')}"` : t; }
  function num(v) { const x = Number(v); return Number.isFinite(x) ? x : null; }
  function safe(v){ return Number.isFinite(v) ? v : 0; }

  // Extract a barcode-looking sequence from a string/link
  function extractBarcodeFromText(text){
    const s = String(text || "");
    // Common UPC/EAN lengths: 8, 12, 13, 14
    const m = s.match(/(\d{8}|\d{12}|\d{13}|\d{14})/);
    return m ? m[1] : null;
    }

  function toast(statusEl, msg) {
    statusEl.textContent = msg;
    setTimeout(() => { if (statusEl.textContent === msg) statusEl.textContent = "Ready."; }, 1600);
  }

  // ---------------------------
  // Elements
  // ---------------------------
  const status = document.getElementById("status");

  // Food input
  const cameraSelect = document.getElementById("cameraSelect");
  const startBtn = document.getElementById("startBtn");
  const stopBtn = document.getElementById("stopBtn");
  const torchBtn = document.getElementById("torchBtn");

  const barcodeEl = document.getElementById("barcode");
  const lookupBtn = document.getElementById("lookupBtn");
  const photoInput = document.getElementById("barcodePhoto");

  const linkInput = document.getElementById("linkInput");
  const linkLookupBtn = document.getElementById("linkLookupBtn");

  const productCard = document.getElementById("productCard");
  const sourcePill = document.getElementById("sourcePill");
  const coveragePill = document.getElementById("coveragePill");
  const prodName = document.getElementById("prodName");
  const prodMeta = document.getElementById("prodMeta");
  const nutriPreview = document.getElementById("nutriPreview");

  const modeEl = document.getElementById("mode");
  const qtyEl = document.getElementById("qty");
  const addBtn = document.getElementById("addBtn");
  const modeHelp = document.getElementById("modeHelp");

  // Verify panel
  const verifyPanel = document.getElementById("verifyPanel");
  const editServingText = document.getElementById("editServingText");
  const editServingGrams = document.getElementById("editServingGrams");
  const editBasis = document.getElementById("editBasis");
  const editKcal = document.getElementById("editKcal");
  const editProtein = document.getElementById("editProtein");
  const editCarbs = document.getElementById("editCarbs");
  const editFat = document.getElementById("editFat");
  const saveOverride = document.getElementById("saveOverride");
  const clearOverride = document.getElementById("clearOverride");
  const verifyStatus = document.getElementById("verifyStatus");

  // Today panel
  const tCalories = document.getElementById("tCalories");
  const tProtein = document.getElementById("tProtein");
  const tCarbs = document.getElementById("tCarbs");
  const tFat = document.getElementById("tFat");
  const saveTargets = document.getElementById("saveTargets");
  const exportCsvBtn = document.getElementById("exportCsv");
  const clearToday = document.getElementById("clearToday");
  const totalsEl = document.getElementById("totals");
  const logBody = document.getElementById("logBody");

  // Workout panel
  const workoutType = document.getElementById("workoutType");
  const muscleGroup = document.getElementById("muscleGroup");
  const workoutCals = document.getElementById("workoutCals");
  const workoutNotes = document.getElementById("workoutNotes");
  const addWorkout = document.getElementById("addWorkout");
  const workoutBody = document.getElementById("workoutBody");

  // ---------------------------
  // Targets
  // ---------------------------
  const targets = LS.get("targets", defaultTargets);
  tCalories.value = targets.calories;
  tProtein.value = targets.protein;
  tCarbs.value = targets.carbs;
  tFat.value = targets.fat;

  saveTargets.addEventListener("click", () => {
    const t = {
      calories: Number(tCalories.value || 0),
      protein: Number(tProtein.value || 0),
      carbs: Number(tCarbs.value || 0),
      fat: Number(tFat.value || 0)
    };
    LS.set("targets", t);
    render();
    toast(status, "Targets saved.");
  });

  // ---------------------------
  // Food + Workout storage
  // ---------------------------
  function getFoods() { return LS.get(FOOD_KEY(), []); }
  function setFoods(items) { LS.set(FOOD_KEY(), items); }

  function getWorkouts(){ return LS.get(WORKOUT_KEY(), []); }
  function setWorkouts(items){ LS.set(WORKOUT_KEY(), items); }

  function sumFoods(items) {
    return items.reduce((acc, it) => {
      acc.calories += it.calories;
      acc.protein += it.protein;
      acc.carbs += it.carbs;
      acc.fat += it.fat;
      return acc;
    }, { calories:0, protein:0, carbs:0, fat:0 });
  }

  function sumWorkouts(items){
    return items.reduce((acc, it) => acc + (Number(it.burned)||0), 0);
  }

  function classify(remaining) {
    if (remaining >= 0) return "ok";
    if (remaining > -150) return "warn";
    return "bad";
  }

  function render() {
    const foods = getFoods();
    const wos = getWorkouts();
    const totals = sumFoods(foods);
    const burned = sumWorkouts(wos);

    const t = LS.get("targets", defaultTargets);

    // Net calories: food - exercise
    const netCals = totals.calories - burned;
    const remNet = t.calories - netCals;

    const remP = t.protein - totals.protein;
    const remCarbs = t.carbs - totals.carbs;
    const remFat = t.fat - totals.fat;

    totalsEl.innerHTML = [
      `<div class="pill ${classify(remNet)}"><b>Net Calories</b> ${netCals.toFixed(0)} / ${t.calories} (rem ${remNet.toFixed(0)})</div>`,
      `<div class="pill"><b>Food Calories</b> ${totals.calories.toFixed(0)}</div>`,
      `<div class="pill"><b>Exercise Burn</b> ${burned.toFixed(0)}</div>`,
      `<div class="pill ${classify(remP)}"><b>Protein</b> ${totals.protein.toFixed(1)} / ${t.protein}g (rem ${remP.toFixed(1)}g)</div>`,
      `<div class="pill ${classify(remCarbs)}"><b>Carbs</b> ${totals.carbs.toFixed(1)} / ${t.carbs}g (rem ${remCarbs.toFixed(1)}g)</div>`,
      `<div class="pill ${classify(remFat)}"><b>Fat</b> ${totals.fat.toFixed(1)} / ${t.fat}g (rem ${remFat.toFixed(1)}g)</div>`
    ].join(" ");

    // Foods table
    logBody.innerHTML = "";
    foods.forEach((it, idx) => {
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td>
          <div style="font-weight:950">${escapeHtml(it.name)}</div>
          <div class="small">${escapeHtml(it.detail)}</div>
          <div class="small">${escapeHtml(it.source || "")}${it.barcode ? " • " + escapeHtml(it.barcode) : ""}</div>
        </td>
        <td class="right">${it.calories.toFixed(0)}</td>
        <td class="right">${it.protein.toFixed(1)}</td>
        <td class="right">${it.carbs.toFixed(1)}</td>
        <td class="right">${it.fat.toFixed(1)}</td>
        <td class="right"><button class="ghost" data-del-food="${idx}" style="padding:8px 10px; font-size:12px;">Delete</button></td>
      `;
      logBody.appendChild(tr);
    });

    logBody.querySelectorAll("button[data-del-food]").forEach(btn => {
      btn.addEventListener("click", () => {
        const i = Number(btn.getAttribute("data-del-food"));
        const next = getFoods().filter((_, idx) => idx !== i);
        setFoods(next);
        render();
      });
    });

    // Workouts table
    workoutBody.innerHTML = "";
    wos.forEach((it, idx) => {
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td>
          <div style="font-weight:950">${escapeHtml(it.type)} • ${escapeHtml(it.muscle)}</div>
          <div class="small">${escapeHtml(it.notes || "")}</div>
        </td>
        <td class="right">${Number(it.burned||0).toFixed(0)}</td>
        <td class="right"><button class="ghost" data-del-wo="${idx}" style="padding:8px 10px; font-size:12px;">Delete</button></td>
      `;
      workoutBody.appendChild(tr);
    });

    workoutBody.querySelectorAll("button[data-del-wo]").forEach(btn => {
      btn.addEventListener("click", () => {
        const i = Number(btn.getAttribute("data-del-wo"));
        const next = getWorkouts().filter((_, idx) => idx !== i);
        setWorkouts(next);
        render();
      });
    });
  }

  clearToday.addEventListener("click", () => {
    setFoods([]);
    setWorkouts([]);
    render();
    toast(status, "Cleared today.");
  });

  exportCsvBtn.addEventListener("click", () => {
    const foods = getFoods();
    const wos = getWorkouts();

    const lines = [];
    lines.push("SECTION, timestamp, name/type, detail/muscle, calories, protein_g, carbs_g, fat_g, burned, barcode, source, notes");

    foods.forEach(it => {
      lines.push([
        "FOOD",
        it.timestamp,
        csv(it.name),
        csv(it.detail),
        it.calories.toFixed(0),
        it.protein.toFixed(1),
        it.carbs.toFixed(1),
        it.fat.toFixed(1),
        "",
        it.barcode || "",
        csv(it.source || ""),
        ""
      ].join(","));
    });

    wos.forEach(it => {
      lines.push([
        "WORKOUT",
        it.timestamp,
        csv(it.type),
        csv(it.muscle),
        "",
        "",
        "",
        "",
        Number(it.burned||0).toFixed(0),
        "",
        "",
        csv(it.notes || "")
      ].join(","));
    });

    const blob = new Blob([lines.join("\n")], { type: "text/csv;charset=utf-8" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `day_${new Date().toISOString().slice(0,10)}.csv`;
    a.click();
    URL.revokeObjectURL(url);
  });

  // ---------------------------
  // Food data model + OFF parsing
  // ---------------------------
  let currentFood = null;

  function guessServingGrams(servingText) {
    if (!servingText) return null;
    const m = servingText.match(/([\d.]+)\s*g/i);
    if (!m) return null;
    const v = Number(m[1]);
    return Number.isFinite(v) ? v : null;
  }

  function parseOFF(product) {
    const n = product.nutriments || {};
    const name = product.product_name || product.abbreviated_product_name || "(Unknown product)";
    const brand = product.brands || "";
    const serving = product.serving_size || "";

    const per100g = {
      kcal: num(n["energy-kcal_100g"]),
      protein: num(n["proteins_100g"]),
      carbs: num(n["carbohydrates_100g"]),
      fat: num(n["fat_100g"])
    };

    const perServing = {
      kcal: num(n["energy-kcal_serving"]),
      protein: num(n["proteins_serving"]),
      carbs: num(n["carbohydrates_serving"]),
      fat: num(n["fat_serving"])
    };

    const hasServing = Object.values(perServing).some(v => Number.isFinite(v) && v > 0);
    const has100g = Object.values(per100g).some(v => Number.isFinite(v) && v > 0);

    const servingGrams = guessServingGrams(serving);

    return {
      name,
      brand,
      servingSizeText: serving,
      servingGrams,
      per100g,
      perServing,
      hasServing,
      has100g,
      source: "Open Food Facts"
    };
  }

  function applyOverride(barcode, baseFood) {
    const overrides = getOverrides();
    const ov = overrides[barcode];
    if (!ov) return baseFood;

    const merged = { ...baseFood };
    merged.servingSizeText = ov.servingText ?? merged.servingSizeText;
    merged.servingGrams = Number.isFinite(ov.servingGrams) ? ov.servingGrams : merged.servingGrams;

    if (ov.perServing) merged.perServing = { ...merged.perServing, ...ov.perServing };
    if (ov.per100g) merged.per100g = { ...merged.per100g, ...ov.per100g };

    merged.hasServing = Object.values(merged.perServing).some(v => Number.isFinite(v) && v > 0);
    merged.has100g = Object.values(merged.per100g).some(v => Number.isFinite(v) && v > 0);

    merged.source = "Verified (You)";
    merged.accuracyNote = `Verified on ${new Date(ov.updatedAtISO).toLocaleString()}`;
    return merged;
  }

  function scaleMacros(macros, factor) {
    return {
      calories: safe(macros.kcal) * factor,
      protein: safe(macros.protein) * factor,
      carbs: safe(macros.carbs) * factor,
      fat: safe(macros.fat) * factor
    };
  }

  function computeForQty(foodData, qty, mode) {
    if (mode === "serving") {
      if (foodData.hasServing) return { macros: scaleMacros(foodData.perServing, qty), detail: `${qty} serving(s)` };
      return { macros: scaleMacros(foodData.per100g, qty), detail: `${qty} × 100g (fallback)` };
    }
    const grams = qty;
    return { macros: scaleMacros(foodData.per100g, grams / 100.0), detail: `${grams} g` };
  }

  function updateModeHelp(data) {
    if (!data) return;
    if (modeEl.value === "serving") {
      modeHelp.textContent = data.hasServing
        ? `Serving mode: uses per-serving values (${data.servingSizeText || "1 serving"}).`
        : `Serving mode: per-serving data not available; using per 100g estimate.`;
    } else {
      modeHelp.textContent = `Gram mode: uses per 100g values scaled to grams.`;
    }
  }

  function updatePreview() {
    if (!currentFood) return;
    const qty = Number(qtyEl.value || 0);
    const { macros, detail } = computeForQty(currentFood, qty, modeEl.value);

    nutriPreview.textContent = JSON.stringify({
      item: currentFood.name,
      barcode: currentFood.barcode,
      amount: detail,
      calories_kcal: Math.round(macros.calories),
      protein_g: round1(macros.protein),
      carbs_g: round1(macros.carbs),
      fat_g: round1(macros.fat),
      source: currentFood.source,
      note: currentFood.accuracyNote || ""
    }, null, 2);
  }

  modeEl.addEventListener("change", () => { updateModeHelp(currentFood); updatePreview(); });
  qtyEl.addEventListener("input", updatePreview);

  async function lookup(barcode) {
    status.textContent = "Looking up barcode…";
    productCard.style.display = "none";
    currentFood = null;

    const url = `https://world.openfoodfacts.org/api/v0/product/${encodeURIComponent(barcode)}.json`;
    let parsed = null;

    try {
      const res = await fetch(url);
      const data = await res.json();
      if (data.status === 1) parsed = parseOFF(data.product);
    } catch {}

    const base = parsed ?? {
      name: "(Unknown product)",
      brand: "",
      servingSizeText: "",
      servingGrams: null,
      per100g: { kcal:null, protein:null, carbs:null, fat:null },
      perServing: { kcal:null, protein:null, carbs:null, fat:null },
      hasServing: false,
      has100g: false,
      source: parsed ? "Open Food Facts" : "No database result"
    };

    const finalFood = applyOverride(barcode, base);
    finalFood.barcode = barcode;
    currentFood = finalFood;

    // UI
    prodName.textContent = finalFood.name;
    prodMeta.textContent = [finalFood.brand, finalFood.servingSizeText].filter(Boolean).join(" • ");

    sourcePill.textContent = `Source: ${finalFood.source}`;

    const hasAll100g = ["kcal","protein","carbs","fat"].every(k => Number.isFinite(finalFood.per100g?.[k]) && finalFood.per100g[k] >= 0);
    const hasAllServing = ["kcal","protein","carbs","fat"].every(k => Number.isFinite(finalFood.perServing?.[k]) && finalFood.perServing[k] >= 0);

    coveragePill.style.display = "inline-block";
    coveragePill.textContent = `Coverage: ${hasAllServing ? "Per serving ✓" : "Per serving —"} • ${hasAll100g ? "Per 100g ✓" : "Per 100g —"}`;

    productCard.style.display = "block";
    updateModeHelp(finalFood);
    updatePreview();
    hydrateVerifyPanel(finalFood);

    if (finalFood.source === "Verified (You)") {
      status.textContent = `Using verified macros for ${barcode}.`;
    } else if (parsed) {
      status.textContent = "Found product. (Tip: verify if you want guaranteed accuracy.)";
    } else {
      status.textContent = "Not found in database. Use Verify/Edit to enter label macros.";
      verifyPanel.open = true;
    }
  }

  lookupBtn.addEventListener("click", () => {
    const code = barcodeEl.value.trim();
    if (!code) return toast(status, "Enter a barcode first.");
    lookup(code);
  });

  // Link → barcode → lookup
  linkLookupBtn.addEventListener("click", () => {
    const link = linkInput.value.trim();
    if (!link) return toast(status, "Paste a link first.");

    const barcode = extractBarcodeFromText(link);
    if (barcode) {
      barcodeEl.value = barcode;
      status.textContent = `Detected barcode from link: ${barcode}\nLooking up…`;
      lookup(barcode);
      return;
    }

    // Special: OpenFoodFacts links often include product/{barcode} or ?code=
    // If no digits detected, tell user the limitation + verify option
    status.textContent =
      "Couldn’t extract a barcode from that link.\n\n" +
      "Because this is a GitHub Pages (front-end only) app, most websites block reading nutrition facts automatically.\n" +
      "Fix: copy the barcode number (digits) from the page into the barcode box, OR use Verify/Edit to enter label macros.";
    verifyPanel.open = true;
  });

  // Add to today
  addBtn.addEventListener("click", () => {
    if (!currentFood) return toast(status, "Lookup a product first.");
    const qty = Number(qtyEl.value || 0);
    if (!Number.isFinite(qty) || qty <= 0) return toast(status, "Enter a quantity > 0.");

    const { macros, detail } = computeForQty(currentFood, qty, modeEl.value);

    const nonZero = macros.calories || macros.protein || macros.carbs || macros.fat;
    if (!nonZero) {
      toast(status, "No macro data yet. Use Verify/Edit to enter label macros.");
      verifyPanel.open = true;
      return;
    }

    const entry = {
      timestamp: new Date().toISOString(),
      name: currentFood.name,
      detail,
      calories: macros.calories,
      protein: macros.protein,
      carbs: macros.carbs,
      fat: macros.fat,
      barcode: currentFood.barcode,
      source: currentFood.source
    };

    const foods = getFoods();
    foods.unshift(entry);
    setFoods(foods);
    render();
    toast(status, "Added food.");
  });

  // Verify/edit
  function hydrateVerifyPanel(food) {
    const overrides = getOverrides();
    const ov = overrides[food.barcode];

    const lines = [];
    lines.push(`Current source: ${food.source}`);
    if (food.accuracyNote) lines.push(food.accuracyNote);

    lines.push("");
    lines.push("Current macro values (for reference):");
    lines.push(`Per serving: kcal=${food.perServing?.kcal ?? "—"}, P=${food.perServing?.protein ?? "—"}, C=${food.perServing?.carbs ?? "—"}, F=${food.perServing?.fat ?? "—"}`);
    lines.push(`Per 100g:    kcal=${food.per100g?.kcal ?? "—"}, P=${food.per100g?.protein ?? "—"}, C=${food.per100g?.carbs ?? "—"}, F=${food.per100g?.fat ?? "—"}`);
    verifyStatus.textContent = lines.join("\n");

    editServingText.value = ov?.servingText ?? (food.servingSizeText || "");
    editServingGrams.value = Number.isFinite(ov?.servingGrams) ? ov.servingGrams : (Number.isFinite(food.servingGrams) ? food.servingGrams : "");
    editBasis.value = (food.servingSizeText || food.hasServing) ? "serving" : "100g";

    editKcal.value = "";
    editProtein.value = "";
    editCarbs.value = "";
    editFat.value = "";
  }

  saveOverride.addEventListener("click", () => {
    if (!currentFood?.barcode) return toast(status, "Lookup a product first.");

    const basis = editBasis.value;
    const kcal = num(editKcal.value);
    const p = num(editProtein.value);
    const c = num(editCarbs.value);
    const f = num(editFat.value);

    if (![kcal,p,c,f].every(v => Number.isFinite(v) && v >= 0)) {
      return toast(status, "Enter Calories, Protein, Carbs, and Fat (all 4).");
    }

    const overrides = getOverrides();
    const existing = overrides[currentFood.barcode] || {};

    const servingText = (editServingText.value || "").trim();
    const servingGrams = num(editServingGrams.value);

    const next = {
      servingText: servingText || existing.servingText || "",
      servingGrams: Number.isFinite(servingGrams) ? servingGrams : (Number.isFinite(existing.servingGrams) ? existing.servingGrams : null),
      perServing: existing.perServing || null,
      per100g: existing.per100g || null,
      updatedAtISO: new Date().toISOString()
    };

    if (basis === "serving") next.perServing = { kcal, protein:p, carbs:c, fat:f };
    else next.per100g = { kcal, protein:p, carbs:c, fat:f };

    // Auto-compute the other basis if serving grams provided
    if (basis === "serving" && Number.isFinite(next.servingGrams) && next.servingGrams > 0) {
      const factor = 100.0 / next.servingGrams;
      next.per100g = { kcal: round1(kcal * factor), protein: round1(p * factor), carbs: round1(c * factor), fat: round1(f * factor) };
    }
    if (basis === "100g" && Number.isFinite(next.servingGrams) && next.servingGrams > 0) {
      const factor = next.servingGrams / 100.0;
      next.perServing = { kcal: round1(kcal * factor), protein: round1(p * factor), carbs: round1(c * factor), fat: round1(f * factor) };
    }

    overrides[currentFood.barcode] = next;
    setOverrides(overrides);

    toast(status, "Saved verified macros.");
    lookup(currentFood.barcode);
  });

  clearOverride.addEventListener("click", () => {
    if (!currentFood?.barcode) return toast(status, "Lookup a product first.");
    const overrides = getOverrides();
    if (overrides[currentFood.barcode]) {
      delete overrides[currentFood.barcode];
      setOverrides(overrides);
      toast(status, "Removed verified data.");
      lookup(currentFood.barcode);
    } else {
      toast(status, "No verified data to remove.");
    }
  });

  // ---------------------------
  // Workouts
  // ---------------------------
  addWorkout.addEventListener("click", () => {
    const type = workoutType.value;
    const muscle = muscleGroup.value;
    const burned = Number(workoutCals.value || 0);
    const notes = workoutNotes.value.trim();

    if (!Number.isFinite(burned) || burned < 0) return toast(status, "Enter calories burned (0 or more).");

    const entry = {
      timestamp: new Date().toISOString(),
      type,
      muscle,
      burned,
      notes
    };

    const wos = getWorkouts();
    wos.unshift(entry);
    setWorkouts(wos);

    workoutCals.value = "";
    workoutNotes.value = "";
    render();
    toast(status, "Added workout.");
  });

  // ---------------------------
  // Photo upload barcode decode
  // ---------------------------
  photoInput.addEventListener("change", async (e) => {
    const file = e.target.files?.[0];
    if (!file) return;

    const Quagga = window.Quagga;
    if (!Quagga) {
      toast(status, "Scanner library not loaded.");
      e.target.value = "";
      return;
    }

    status.textContent = "Decoding barcode from photo…";
    const url = URL.createObjectURL(file);

    Quagga.decodeSingle({
      src: url,
      numOfWorkers: 0,
      locate: true,
      decoder: { readers: ["upc_reader", "ean_reader", "ean_8_reader"] }
    }, (result) => {
      URL.revokeObjectURL(url);
      const code = result?.codeResult?.code;

      if (!code) {
        status.textContent = "Couldn’t decode that photo.\nTip: crop tight + brighter light + avoid blur.";
        e.target.value = "";
        return;
      }

      barcodeEl.value = code;
      status.textContent = `Decoded from photo: ${code}\nLooking up…`;
      lookup(code);
      e.target.value = "";
    });
  });

  // ---------------------------
  // Scanner (Quagga2)
  // ---------------------------
  const Quagga = window.Quagga;
  if (!Quagga) status.textContent = "Quagga failed to load. Check CDN + redeploy.";

  let scanning = false;
  let lastDecoded = null;
  let torchOn = false;

  async function listCamerasForDropdown() {
    try {
      const devices = await navigator.mediaDevices.enumerateDevices();
      const cams = devices.filter(d => d.kind === "videoinput");
      cameraSelect.innerHTML = "";
      cams.forEach((d, i) => {
        const opt = document.createElement("option");
        opt.value = d.deviceId;
        opt.textContent = d.label || `Camera ${i + 1}`;
        cameraSelect.appendChild(opt);
      });

      const savedRear = LS.get("rearCamDeviceId", null);
      if (savedRear) cameraSelect.value = savedRear;
    } catch {}
  }

  function supportsTorch() {
    try {
      const track = Quagga.CameraAccess.getActiveTrack?.();
      const caps = track?.getCapabilities?.();
      return !!caps?.torch;
    } catch { return false; }
  }

  async function setTorch(on) {
    try {
      const track = Quagga.CameraAccess.getActiveTrack?.();
      if (!track) return toast(status, "No active camera track.");
      const caps = track.getCapabilities?.();
      if (!caps?.torch) return toast(status, "Flashlight not supported.");

      await track.applyConstraints({ advanced: [{ torch: on }] });
      torchOn = on;
      torchBtn.textContent = `Flashlight: ${torchOn ? "On" : "Off"}`;
    } catch {
      toast(status, "Could not toggle flashlight.");
    }
  }

  torchBtn.addEventListener("click", async () => { await setTorch(!torchOn); });

  function onDetectedHandler(data) {
    const code = data?.codeResult?.code;
    if (!code) return;
    if (code === lastDecoded) return;
    lastDecoded = code;

    barcodeEl.value = code;
    status.textContent = `Decoded: ${code}\nLooking up…`;

    setTimeout(() => {
      stopScan();
      lookup(code);
    }, 250);
  }

  cameraSelect.addEventListener("change", async () => {
    if (!scanning) return;
    await stopScan();
    await startScan();
  });

  async function startScan() {
    if (!Quagga) return toast(status, "Quagga not loaded.");
    if (scanning) return;

    scanning = true;
    lastDecoded = null;
    status.textContent = "Starting scanner… (Quagga2)";

    await listCamerasForDropdown();

    let chosenId = cameraSelect.value || null;
    const savedRear = LS.get("rearCamDeviceId", null);
    if (savedRear) chosenId = savedRear;

    try { Quagga.offDetected(onDetectedHandler); } catch {}
    try { Quagga.stop(); } catch {}
    try { Quagga.CameraAccess.release(); } catch {}

    const targetEl = document.getElementById("quaggaTarget");
    if (targetEl) targetEl.innerHTML = "";

    Quagga.init({
      inputStream: {
        type: "LiveStream",
        target: targetEl,
        constraints: {
          facingMode: { ideal: "environment" },
          width: { ideal: 1280, min: 640 },
          height: { ideal: 720, min: 480 },
          ...(chosenId ? { deviceId: chosenId } : {})
        }
      },
      locator: { patchSize: "medium", halfSample: true },
      locate: true,
      decoder: { readers: ["upc_reader", "ean_reader", "ean_8_reader"] }
    }, (err) => {
      if (err) {
        scanning = false;
        status.textContent =
          "Scanner error:\n" + (err?.message || String(err)) +
          "\n\nFixes:\n- iPhone Settings → Safari → Camera = Allow\n- Open in Safari (not in-app browser)\n- Reload with ?v=NEW";
        return;
      }

      Quagga.start();

      // Save active deviceId so iPhone stops flipping to front camera
      try {
        const track = Quagga.CameraAccess.getActiveTrack?.();
        const settings = track?.getSettings?.();
        if (settings?.deviceId) LS.set("rearCamDeviceId", settings.deviceId);
      } catch {}

      if (supportsTorch()) {
        torchBtn.style.display = "inline-block";
        torchBtn.textContent = `Flashlight: ${torchOn ? "On" : "Off"}`;
      } else {
        torchBtn.style.display = "none";
        torchOn = false;
      }

      status.textContent = "Scanning… (Quagga2)\nTips: fill the frame, avoid glare, hold steady 1–2s.";
    });

    Quagga.onDetected(onDetectedHandler);
  }

  async function stopScan() {
    if (!Quagga) return;

    scanning = false;

    if (torchOn) {
      try { await setTorch(false); } catch {}
    }

    try { Quagga.offDetected(onDetectedHandler); } catch {}
    try { Quagga.stop(); } catch {}
    try { Quagga.CameraAccess.release(); } catch {}

    const tgt = document.getElementById("quaggaTarget");
    if (tgt) tgt.innerHTML = "";

    status.textContent = "Scanner stopped.";
  }

  startBtn.addEventListener("click", startScan);
  stopBtn.addEventListener("click", stopScan);

  // ---------------------------
  // Initial render
  // ---------------------------
  render();
</script>
</body>
</html>
